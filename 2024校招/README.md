# 秋招记录

这里会把反复忘记的八股分门别类的整理

然后记录面试中没有答上来的问题，抓紧查漏补缺吧

## 分门别类

网络 > 数据库 > 系统设计 > 语言特性 > 操作系统

### 网络编程

* TCP/IP 

  * 握手挥手状态 （TIME_WAIT意义）

    * 三次握手流程
      * 客户端发送 SYN ，状态为 SYN_SENT。SYN占用一个序列号，超时未回复会重传 SYN
      * 服务端接收 SYN 并回复 SYN-ACK，状态为 SYN_RCVD。服务端维护一个半连接队列，存储未完成握手的链接。若队列满，可能触发 SYN Flood 攻击防御
      * 客户端回复 ACK ，双方进入 ESTABLISHED 状态。服务端将链接从半连接队列移至全连接队列，等待 accept() 调用
    * 四次挥手流程
      * 客户端发送 FIN ，进入 FIN_WAIT_1 状态，客户端不再发送数据，但仍可接收数据。FIN 占用一个序列号，触发超时重传机制
      * 服务端回复 ACK ，进入 CLOSE_WAIT 状态。发送未传完的数据
      * 服务端数据处理结束，发送 FIN，进入 LAST_ACK 状态
      * 客户端发送 ACK ，进入 TIME_WAIT 状态，结束后关闭链接
    * TIME_WAIT意义
      * 持续 2 * MSL，默认60秒，Linux可调参数
      * 若 FIN 丢失，客户端可在 TIME_WAIT 状态重发 ACK
      * 等待网络中属于此链接的报文过期
      * 高并发短连接场景下，端口可能被占满。可降低 MSL 时间

  * 粘包拆包解决方案

    * 原因：TCP 是字节流协议，无消息边界，可能会将报个报文混在一起
    * 严格固定长度，不足部分填0. 浪费带宽，不适用于变长数据
    * 以特定字符（\n, \r\n）分割消息。需要处理转义字符
    * 消息头声明长度
    * 高级序列化协议（Protobuf/Thrift) ，自带长度标识
    * Netty 拆包器

  * 流量控制 （滑动窗口）

    * 基于接收方缓冲区的端到端控制，防止接收方被压垮
    * 发送窗口：已发送未确认的数据+可发送的数据
    * 接收窗口：接收方缓冲区剩余空间（通过TCP头部通知发送方）
    * 当接收方窗口为0时，发送方停止发送，并启动定时器（每过一段时间，发送1字节的探测报文）
    * 接收方缓冲区释放后，发送ACK携带新窗口大小

  * 拥塞控制 （拥塞窗口）

    * 网络拥塞时，容易触发重传，重传会导致网络更加拥塞

    * 慢启动：创建链接后，维护一个 cwnd ，初始为1，成功发送一个报文后（收到ACK回复），cwnd+1， 每次都发送 cwnd 个报文

    * 拥塞避免算法：当 cwnd 足够大后，每收到一个 ACK ，cwnd += 1/cwnd

    * 超时重传：触发重传后，重新启动慢启动流程

      ![拥塞发送——超时重传](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

    * 快速重传：发送三次前一个包的ACK，进行快速重传。cwnd = cwnd/2![快速重传和快速恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

* 网络模型

  * Reactor
    * 事件驱动+非阻塞 I/O，由事件循环监听就绪事件并分发给对应处理器
    * 应用将 IO 事件（读、写）注册到 Reactor
    * Reactor 调用 select/poll/epoll 监听事件
    * 将就绪事件分发给预先注册的处理器
    * 处理器执行非阻塞 IO 操作，如 read、write
  * Proactor
    * 异步 IO，操作系统完成 IO 操作后通知应用层
    * 简化应用逻辑，适合长连接或大数据传输
  * Select 、Poll 、Epoll ET/LT
    * select
      * 通过 fd_set 监听多个文件描述法，调用 select() 阻塞直到有事件就绪
      * 每次调用需要从用户态拷贝 fd_set 到内核态，内核遍历检查，有事件就绪后重新拷贝到用户态，用户再次遍历
      * 最大数量默认 1024
      * 只能 LT
    * poll
      * 用链表 pollfd 代替 fd_set，解除最大数量限制
      * 仍需遍历所有 fd
      * 只能 LT
    * epoll
      * 红黑树 + 就绪链表，仅需要注册时拷贝以此 fd
      * 通过回调函数，返回就绪的 fd
      * 水平触发 LT：只要 fd 处于就绪状态，epoll_wait 就会通知
      * 边缘触发 ET：仅在 fd 状态变化时通知一次
  * 零拷贝技术
    * 发送文件时，磁盘 -> 内核缓冲区 -> 用户缓冲区 -> 内核 socket 缓冲区 ->网卡，需要反复拷贝
    * mmap + write 将内核缓冲区映射到用户空间
    * sendfile 将数据直接从内核缓冲区传输到 socket 缓冲区，无需经过用户态

* HTTP 协议

  * Keep-Alive 机制与队头阻塞问题
    * HTTP/1.0 默认每个请求需新建 TCP 连接，频繁的握手和挥手导致高延迟
    * HTTP/1.1 启用 keep-alive，允许在单个 TCP 连接上发多个 HTTP 请求
      * 优势
        * 减少 TCP 连接数，降低延迟和消耗
        * 避免重复 TLS 握手，HTTPS 场景性能显著提升
        * keep-alive：timeout=5，max=100，空闲5s后关闭，最多处理100个请求
      * 缺点
        * HTTP/1.1 必须按请求顺序返回响应，某个请求处理较慢，后续请求会被阻塞
    * HTTP/2 多路复用，通过分帧（Frame）并行传输多个请求。若TCP丢包，仍会触发重传，导致传输层队头阻塞
    * HTTP/3 基于 UDP，每个 Stream 独立传输，彻底消除队头阻塞
  * HTTPS 握手过程 （ECDHE密钥交换）
    * HTTPS = HTTP + TLS/SSL，非对称加密协商对称密钥
    * 客户端发送支持的 TLS 版本，加密套件，随机数
    * 服务端返回加密套件，新的随机数，证书（含公钥），ECDHE参数
    * 客户端验证证书有效性（颁发机构、有效期、域名匹配）
    * 客户端生成临时密钥对，发送公钥
    * 客户端和服务端分别通过伪随机函数生成 主密钥，再派生出对称加密密钥和MAC密钥
    * 双方发送 Finished 消息验证密钥一致性，后续使用对称加密
  * RESTful API 设计规范
    * 一种架构风格，核心是资源导向和无状态通信
    * 六大核心约束
      * 客户端-服务器分离，前后端解耦
      * 无状态，服务端不保存客户端上下文，每次请求包含完整消息
      * 缓存，响应明确是否可缓存
      * 统一接口，资源标识、自描述消息
      * 分层系统，如负载均衡、网关、CDN对客户端透明
      * 按需代码，服务端可返回可执行代码

项目结合点：

* 云备份系统如何解决大文件传输粘包问题
* Epoll ET 在 Reactor 模型中的应用

### 数据库

* MySQL

  * B+ 树索引结构 
  * 间隙锁与幻读解决方案 （MVCC 实现）
  * 慢查询优化流程 （EXPLAIN 执行计划）
* 事务机制

  * ACID 实现原理 （redo / undo log）

  * 隔离级别与并发异常 （脏读/幻读）

* Redis

  * 持久化方案对比 （RDB/AOF 混合持久化）
  * 集群分片方案 （Codis vs Cluster)
  * 热 key 发现与处理方案

项目结合点

* 云音乐平台中组合索引优化

* Redis 管道技术提升榜单更新效率

### 系统设计

* 分布式系统
  * CAP 理论实践取舍 （结合 Redis 集群）
  * 分布式锁实现方案 （Redlock算法缺陷）
  * 幂等性保障机制 （Token机制/状态机）
* 缓存设计
  * 缓存穿透/击穿/雪崩解决方案
  * 一致性哈希算法实现原理
  * 多级缓存架构 （Caffeine + Redis）
* 消息队列
  * kafka 副本同步机制 （ISR集合）
  * 消息丢失/重复消费解决方案
  * 延迟队列实现方案 （时间轮算法）

项目结合点
* 云音乐平台中 kafka 削锋方案
* Redis 延时双删实现缓存一致性

### C++ 八股

* 内存管理
  * 智能指针 （unique_ptr / shared_ptr 循环引用解决方案）
  * new / malloc 区别及内存对齐原理
  * 虚函数表机制与多态实现 （vptr/vtable内存布局）
* 并发编程
  * 线程同步机制 （互斥锁/条件变量/读写锁）
  * 无锁编程 （CAS实现原理，ABA问题）
  * 原子操作与内存顺序 （memory_order 参数选择策略）
* STL源码问题
  * vector 扩容机制与迭代器失效场景
  * unordered_map 哈希冲突解决方案 （开链法 vs 探测法）
  * 红黑树特性及map排序实现原理

项目结合点

* 云备份系统中如何避免内存泄漏（智能指针使用案例）
* 多 Reactor 模型中的线程同步方案

### Go八股

* 协程机制
  * GMP 调度模型（M : N 调度实现原理）
  * channel 底层结构 （环形队列 + 互斥锁）
  * 协程泄漏检测与pprof使用
* 内存管理
  * 逃逸分析机制 （栈分配 vs 堆分配）
  * GC 三色标记法 （STW优化策略）
  * sync.Pool 应用场景与注意事项
* 并发模式
  * context 传播机制与超时控制
  * errgroup 使用场景
  * sync.Once 单例模式实现

项目结合点

* 云音乐平台中如何用 channel 实现播放状态同步
* Goroutine 泄漏检测案例

### 操作系统

* 内存管理
  * 虚拟内存机制 （页表寻址）
  * 内存分配算法 （Buddy/Slub分配器）
  * 缺页中断处理流程
* 进程调度
  * 完全公平调度器 （CFS红黑树实现）
  * 进程间通信方式 （共享内存 vs 消息队列）
  * 协程与线程调度差异
* 文件系统
  * inode结构设计与数据寻址
  * 文件描述法与epoll底层实现
  * 文件空洞（hole）与零拷贝关系

项目结合点

* 云备份系统中文件压缩与磁盘调度算法选择

## 科大讯飞 - 后端开发

### 一面

1、文件系统是干什么的

* 数据存储：将数据存储在磁盘或其他存储介质上，确保数据的持久性。
* 文件组织：管理文件和目录的层次结构，使用户能够通过路径方便地访问文件。
* 权限管理：控制用户对文件和目录的访问权限，确保数据安全。
* 数据检索：提供高效的数据查找机制，以快速定位文件。
* 数据完整性：确保数据在写入和读取过程中的完整性，防止数据损坏。
* 常见的文件系统包括NTFS（Windows）、ext4（Linux）、HFS+（macOS）等。不同的文件系统可能有不同的特点和功能。

2、加密方面的内容

3、设计模式

4、C++怎么实现跨平台

* 使用标准库，在大多数主流编译器上都支持
* 抽象平台特性，封装特定平台的代码，如文件系统、网络通信。创建接口和基类来定义不同平台的实现
* 条件编译，如宏定义，检查不同操作系统，选择不同的实现
* 第三方的跨平台库，如 Qt
* 跨平台构建工具，如cmake

### 二面

1、设计模式

感觉要完蛋，一面的内容，到二面还是不会

2、大模型了解程度

毛都不知道

3、c++的三大特性，六大设计原则

4、自己平时的学习过程

## 好未来 - C++开发工程师 - 实习转正

1、介绍左值、右值

2、介绍智能指针

3、websocket 的 应用场景

4、数组和链表遍历谁快？硬件方面的因素有什么

5、vector扩容是怎么实现的

## 虎牙 - 后端开发

1、加锁以后，抛了异常，导致锁没有释放，怎么解决

2、写一个函数判断大端、小端

小端：数据低位保存在低地址    
大端：数据低位保存在高地址    
定义一个 int 值为 1，然后将地址强制转化给一个 char* 就可以得到这个 int 的前四位    
如果这个 char* 的值是 1，说明是小端，否则是大端    
```c++
solve() {
    int i = 1;
    char c = *((char*) &i);
    if (c) cout << "小端";
    else cout << "大端";
}
```

## 巨人网络 - 游戏开发

1、C++的多态是怎么实现的

2、webServer 项目中，收到的报文大小超过 Buffer 大小，怎么扩容

## 4399

一面挺顺畅的，面试官给予高度评价

二面 hr 给挂了，不知道哪里没答好
